



COURSERA GIT COURSE 





WEEK 1: 



git help [command] --> gets help of a specific command

git or git help 

git [command] -h --> to get specific help of that command  	


-------------------How to read git help ??---------------------------

-f --flag --> options or swithces

|      (or) --> represents that a single flag can be written in different ways   Example (-v|-verbose)

[]     (opional values)

<>     (placeholders)  --> this are ment to be repleced with an actual value 

[<>]   (optinal placeholder)

()     (parenthesis) --> used for grouping clarity or to disambiguate a command 

--     --> to disambiguate the command

...   (multiple ocurrences are posible)

---------------------------------------------------------------------


gti config [--local|--global|--system] <key> [<value>]

--local  --> applies to only the current repository 
--global --> applies to every repository that you use on your computer 
--system --> applies to every repository for all users on your computer 


git config user.name --> get the username of teh repository local>global>system
git config <key>


git config --global core.editor <editor> --> to change the default git editor 

---------------------------------------------------------------------

There are three different parts in a PROYECT DIRECTORY.  

Working Tree -> directory with the current project 
Staging area -> contains the files that are going to be added to the next commit 
Local Repository -> Is alll teh info about the history of a proyect 


PROYECTDIRECTORY  contains (WorkingTree and /.git).
./git contains (Staging Area and Local Repository).

---------------------------------------------------------------------

git init --> to create a local repository 

git status --> shows the current branch and shows the status of working threee and stagging area 

git add <file/folder> --> adds a single file or a folder with all the files includede to the stagging area
git add . --> adds al untracked files to the stagging area

git log --oneline --> to see a reduced version of the git log 

git log -3 --> shows only the last 3 commits 


git checkout -- <filete> --> to copy last commit into the working directory

---------------------------------------------------------------------------

git remote add origin https://github.com/jpitagc/gitCourse.git --> add a remote repository to the local 

git push -u origin master --> push the local repository branch master to the remote 


-------------------------------------------------------------------------

origin --> is the default url where you push your local repository.

in this case origin is  https://github.com/jpitagc/gitCourse.git

you can add as many remote repositories as needed and give them the name you want 


-------------------------------------------------------------------------

How to start a remote repository??

If you already have some work done -> add the remote 
if you dont have a local repo yet --> clone the remote 


git clone  --> creates a local copy of a remote repository. 
git clone <url> [localProjectName] --> if you specify a localProjectname the working directory will be created with this providede name whereas if you dont provide de name the default name will be used (url.substract(.git))



git remote add <name> <url> --> name (origin by default) url(hhttp://github...)

git remote --verbose --> will thisplay the remote repository to witch this local is pushing/fetching to/from 
             -v

git push [<repository>] [<branch>] --> repository default is origin 







WEEK 2:



git commits woks as a Directed Acyclic Grapgh.

git log --graph --> will display this graph with all branches

----------------------------------------------------------------------

git object --> git uses objects to store all the date os a repository 
               there are 4 kinds os objects 

               	Commit object --> Simple text file that contains information such as : commit user info, commit message, reference to commit parent(s), reference to the root tree of the proyect.

               	Annotated tag --> reference to a specific commit 

               	Tree          --> contains directories and file names of the proyect 

               	Blob          -->  stores the content of a file that is being managed by git 



Normal git users only interat with commit object and tags but not directly with the entitiy that contains them (object store) but throw git commands

---------------------------------------------------------------------------------
GIT ID      (hashes, SHA-1 ,objectids... ) --> name of a git object. All object have a 40 character hexadecimal string  
  Secure Hash Algorithm 1 --> git hash-object <filename> --> is used internally to generate SHA-1 string (not normally used by end users) This non used command are called Plumbing commands 

  Git shorttens the git IDs to a 7 first character version for efficiency. User can manage this ids by only the fist 7 characters if no two object have the same 7 first SHA-1 characters identicall.

  Git show <ObjectId> --> you can write as few characters as the internal code can only retrived 1 object 

  --------------------------------------------------------------------------

  References: --> Userfriendly name that point to a commit SHA-1 value or another reference. Refences that point to other references are called symbollic references.
                  Head,Master,... are examples of references 

  A branch lavel/ reference (master,develop...) points to th emost recent commit of that branch. is called the tip of the branch  

  This references are stored in the ./git  

  If you enter .git you can navigate to refs/ where references are stored. In a x number of folders this references are stored as simple text files that contain the SHA-1 string to the object they point to.

  HEAD --> is a reference of the current commit. it ussually point to the branch lavel of the current branch. tehre is only one reference of head in a repository meaning that if you change branches teh HEAD will change to the last commit of this new branch.
       cat .git/HEAD ---> ref: ref/heads/master      The content of teh file HEAD i sthe relative path to the current reference its pointing to. Its a symbolic reference 

GIT LOG EXAMPLE
  e6050de (HEAD -> master, origin/master, origin/develop, develop) Week 1 Terminated. This means that Head reference points to master referece that points to the object with SHA-1 e6050de


How to reference to other commits??? using ~ and ^ (We can use this with any reference or any objectId)

~ or ~1 --> parent 
~~ or ~2 --> grandparent   

^ or ^1 --> shows the first parent of a merge commit 
^2 --> shows the second parent of th emerge commit 
^^ --> shows the first parent first parent of the merge commit

this characters can be combined as wanted to navigate throw the git graph


TAG is a label for a specific commit. 
		There are two types:  
								LightWeight Tag --> implemented as a simple reference. Point to a certain object of git 

								Annotataed Tag --> one of the four git objects listed before. Is similar to a commit object beacuse it includes metadata (tag author info, tag date, tag message and Id of the object referenced)
													this tags can be signed and verify with GNU Privacy Guard. Enables managers to sign releases. There are often better than lightweight tags 

You can use tag as refeerences to show commits--> git show 1.0.9

How to add tags to a commit??

git tag <tagname> [<commit>]   example   git tag 1.0.13 master   --> by default git uses HEAD if no other reference or cmmit is specified by the command

git tag -a [-m <msg> | -F <file>] <tagname> [<commit>] --> to create a annotated tag. U must specify a tag msg, thsi can be done in several ways. 1. -m "message"
																																				  2. -F filename
																																				  3. No to specify flag so an editor will open so that you can write the message  

para borrar un tag del remote. -->  git push origin :refs/tags/<tagname>

git push -->  will not push the tags created.
git push <remote> <tagname> --> to push a single tag
git push <remote> --tags --> to push all tags 

-------------------------------------------------------------------------------------

BRANCHES
  
 Branch are simple and easy. The only create a reference.
 They are used to isolate certain work so it dosent affect others. Branches are not aware of other branches.
 Enable team development. Merging later is not nrmally difficult 
 Support for multiple versions at the same time.

 Types: 
        1. Short-lived: also called topic of feature branches. Normally just contained a small change to the forject(new feature, bug fix, config change, ...)
        2. Long-runnig: Live longer. Master or develop branch.

 git branch --> to see the branches of the repository. the current branch will be highlighted in other color.
 
 A- git branch <name> --> creates a reference for the new branch but it dosent change branch 
 B- git checkout <branch or commit> --> switches the HEAD reference to point to the specified branch label and updates the working tree with the files corresponding to that branch  

 C = A + B = git checkout -b <branchname> --> this will combine both the creation and the checkout of a new branch. It fails if the branch already exists.


 git checkout <commit> --> this can be done to see the code of an specific commit as the working tree will load the files of that especific commit. Now HEAD will point to that specific commit.
                           This is known as a [DETACHED HEAD STATE] meaning that instead of the HEAD reference pointing to a branch label points directly to the SHA-1 of a certain commit 
                                         this is perfectly fine to check the staged code of a certain previous commit. If you want to contnue from that deteached head state to develop code you first need to create a branch from that commit
                                         Steps: 
                                                1. Move to the commit desired (detached ehad state)
                                                2. Create a new branch 
                                                3. Checkout thta branch 




 git branch -d <branchname> --> to delete a certain branch reference. Branch labels are often deleted after merging with the master branch (short-lived branches). 

 git nomally wont allow you to delete branches that point to non-merged commits (only in this branch being deleted) beacuse work will be lost. 
 git branch -D <branchname> --> will force a branch delete even if this commits are't merged with other branches. Data loss will occur only when git cleans dangling(colgante) commits. This is done perodically as (garbage collector)

 git reflog (only works locally) returns a local list of recent HEAD commits.

git checkout -b <branchName> <commit> --> crates branch and checkouts in the specified commit 


When on a DETACHED HEAD STATE git log will only show commit from root until that head.  git log --all will print all branches and commits


git branch -d develop  --> deletes branch ref in local 
git push origin -d develop --> deletes them ref in remote 


-------------------------------------------------------------------------------------

Merging 

Types: 
       1. Fast-forward merge: moves the branch label to the tip of the topic branch. The branches have teh same commits now. Is the default merge. 

                     master:   a                             master: a           c 
                                \            ---> Merge --->          \         /
                     develop:    a - b - c                    develop: a - b - c 

            OJO --> The fast-forward merge is posible if no other commits have been made to the master bracnch bracuse if this is not the case the last commit of the branch woul have info that the branch dosent.
                     master:   a - d 
                                \
                     develop:    b - c    


       2. Merge commit : combines commits of the two tips of branches being merged. This could lead in a merge comflict if both branches change the same code in different ways. 

                    master:   a - d -  d   If no conflicts are encountered a merge commit and a fast forward commmit will be done in the same way: 1. git checkout master       
                                \     /                                                                                                            2. git merge <branch>
                     develop:    b - c                                                                                                             3. git branch -d <branch> (if deleted is needed)
          
            Merge commits can be done even if the master branch has no new commits since the branch of this topic branch. This will let the git graph still show the previous branch at any time in the history of the proyect.

                     git merge --no-ff <branch> --> --no--fastforward



       3. Squash Merge 
       4. Rebase





WEEK 3:


 RESOLVING MERGE CONFLICTS 

In case two different branches make changes to the same part of a file. A person needs to make a decision in how to resolve this conflicts. Here fast-forward merges are not posible 
When git is about to combine the work of these two branches it sees that the work on the same file is different in each branch. 
In case different files are changed there is no problem in merging as git will know to take all the new data from both branches.  

Git can also merge brenches that changed the same file if this change affects to different HUNKS.
Example. If a branch develop is used to fix a bug form already committed code and the master branch is used to add a new feature(both in teh same file), merging would not derive in a a merging commit as git would know how to save all the progress.

Th way git merge the files depends on the merge-strategy. 

To avoid merging conflicts its better to use branches for small bug/features and merge as much as posible so that different branches dont diverge in code too much. Avoid braching a branch as much as posible. Modular software is less propense to deal with merge conflcits.


RESOLVING MERGE CONFLICTS INVOLVES THREE COMMITS.

1. The tip of the topic branch being merge. This commit is called "THEIRS"
2. The tip of the master branch. This commit is called "OURS"/"MINE"
3. A common ancestor. The commit where the topic branch was created. This commit is calles "MERGE BASE" 

Basic Steps: 
            1. Chechout master branch 
            2. Trying to merge the topic branch. CONFLICT 
            3. Fix the files that produce the conflict
            4. Stage files changed
            5. Commit the merge 
            6. Optionally delete de topic branch  

The key in this conflicts is that file with conflcits are modified by git and placed in the working tree.


Process of conlfict resolving

-git merge <topicbranch> --> Conflict shown by git 
-git status --> will show that tou have unmerged paths and would sow many options. (git merge --abort)

now git would add all the info of the different copies of teh files that result in a conflicts in this way.

feature 1 
<<<<<<<<<< HEAD 
feature 2          --> Form OURS commit 
===========
feature 3          --> From THEIRS commit 
>>>>>>>>> topicbranch

once the file is fixed 

-git add <file> --> to teh statgin area 
-git commit --> you can edit the message if desired but now the branches are already merged.
-git status --graph --> to see teh actual merge
-git branch -d <topicbranch> --> optionally delete the topic branch as all work is commited to the master branch.


------------------------------------------------------------------------------------------------------------------------

TRACKING BRANCHES (remote branches) 

local branch that represent a remote branchs. --> <remote>/<branch> (origin/master)

when you clone a remote repository the exact same references (master && HEAD && ...) are copied in the exact same way and coverted to local references. Remote references are algo copied to the graph. 

tracking branches are only updated with git network commands such as clone/push/pull...  When you commit a branch with teh remote branch pushing to the last tip of the branch this reference will continue to point to the same commit until ypu push the new commit.

- git branch --all --> will show all local and remote branches.  

 HEAD -> origin/master will also appear. remember this is a symbolic reference. This is a really important reference beacuse is teh place where code willl be push in the remote repo. 

 - git log origin/master --oneline
 - git log origin --oneline --> origin will get the HEAD reference in the remote repo.


 - git remote set-head <remote> <branch> --> this will set de HEAD reference to the tip of the branch specified. 



 - git log --all --> to see a log of lcoal+remote repos to see if any colleague has made any changes.



 ---------------------------------------------------------------------------------------------------------------------------

 FETCH,PULL AND PUSH 

 Network Commands --> Clone, Fetch, Pull, Push.

 FETCH  -> Retrives new objects and references form the remote repository. Updates all of the traking branches. 
          It is used to see if changes have been done to ht eremote repo without pulling them. 
          Tracking references might have changed. Fetching wont change local references.

          - git fetch --> this will display somthing if git objects have been fetched.
          - git status --> will infomr you if yout current local branch is behind the tracking branch.
                           (your branch is behins '<remote>/<brnach>' by x commits, and can be fast-forwarded 
                             use git pull to update your local branch) 

 PULL  -> Fetches and merges commits locally.  FETCHED_HEAD: is an alias for the tip of the tracking branch. 

         new objects and references form the remote repo are fetched. If new objects are added to the tracking branch, the tracking branch is merged into the local branch. The current branch is assumed if branch is not specified.

         merging options: 
                          . --ff (default): fast forward if posible. Otherwise perform a merge commit.
                          . --no-ff: allways include a merge commit
          git pull        . --ff-only: cancel if fast forward is not posible. avoid a merge commit 
                          . --rebase [--preserve-merges]: further discussed

        - GIT PULL WITH FAST FORWARD MERGE:
            1. git status --> your branch is behind remote by 1 commit
            2. git pull 
            3. git log --> to check that our local master label is posinting to teh master tracking label

        - GIT PULL WITH CONFLICTING UNCOMMITTED CHANGES (IF CHANGES HAVE BEEN MADE TO TEH FILES THAT ARE BEING PULLED) --> is this case teh pull acts like a merge form a topic local branch but with the remote tracking master branch 
            1. git pull --> your local changes to the following files would be overwitten by merge. Please commit your changes or stash before you merge. Aborting.
            * only if conflict occur. If you hacve made changes to files that didnt change in the new remote commit the merge will continue succesfully.
            2. fix the file to get what you desire 
            3. git add <file>
            4. git merge --continue 

 PUSH  ->  git push [-u] [<reposiroty>] [<branch>] --> repo can be a name (origin) or the actual url. -u option will create a local tracking reference of this branch.

Fetch or pull beafore you push is suggested. if new remote commits appear when you are about to push this command will be aborated.



-----------------------------------------------------------------------------------------------------------------------------

REBASING  --> this rewittes commits so this should be done with caution. GENERAL RULE- do not rebase history that is been shared with others.

Types: 
        1. Regular Rebase: moves commits to a new parent. Because teh ancestor chain is different, each of teh reapplied commits has a different commit ID (b',c').
                            No longer need a merge commit(because there's no new commits in the amster branch) and the merge of teh branch can be fast-forward. 
                            Rebasing is a type of merge so is succeptible to merge conflicts.
                            Be aware that the conflict you are resolving are for the feture branch. 
                                      
                   EXAMPLE:     b - c                            b' - c'  
                               /        --> REBASE -->          /
                              a - d                        a - d 


                  Pros : 
                         - You can incorporate changes from the parent branch. It makes tha eventual merge into master fats-forwardable 
                         - Avoids unnecesary commits as merge commits often are 'stupid' --> define clean commit history 
                  Cons : 
                         - Megre conflicts may need to be resolve 
                         - Can cause problems if commits have been shared (new ID's)
                         - Your are changing the commit history

                  How to perform a Rebase --> git checkout <topicbranch> and git rebase master                |_ This would change the current branch parent to the tip of the master branch
                                                                         or  git rebase master <topicbranch>  | 


                   MergeConflicts --> git checkout <topicbranch>
                                      git rebase master   
                                      -----CONFLICT-----                      ---> BEFORE RESOLVINF THE CONFLICT YPU CAN ABORT IT: git rebase --abort 
                                      * Fix files that caused the problems 
                                      git add <file>
                                      git rebase --continue


        2. Interactive Rebase 






